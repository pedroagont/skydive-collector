<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Skydive Collector</title>

    <!-- Basic SEO -->
    <meta
      name="description"
      content="Dive from 17,000 ft in Skydive Collector! Collect balloons, race through the clouds, and land safely. Play on desktop or mobile with tilt controls."
    />
    <meta
      name="keywords"
      content="skydiving game, Skydive Collector, balloon collector, 3D browser game, Three.js skydiving, WebGL game, freefall simulator, tilt control game, parachute game, arcade sky game"
    />
    <meta name="author" content="Pedro Gonzalez" />
    <link rel="icon" type="image/png" href="./favicon.png" />

    <!-- Open Graph / Facebook -->
    <meta
      property="og:title"
      content="Skydive Collector Game"
    />
    <meta
      property="og:description"
      content="Skydive from 17,000 ft, collect glowing balloons, and beat the high score! Works on desktop (WASD/Arrows) & mobile tilt controls."
    />
    <meta
      property="og:image"
      content="https://skydrop-collector.onrender.com/preview.jpg"
    />
    <meta property="og:url" content="https://skydrop-collector.onrender.com" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Skydive Collector" />
    <meta property="og:locale" content="en_US" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="Skydive Collector Game"
    />
    <meta
      name="twitter:description"
      content="Jump from 17,000 ft, race through the sky, and collect balloons before landing! Play on desktop or mobile."
    />
    <meta
      name="twitter:image"
      content="https://skydrop-collector.onrender.com/preview.jpg"
    />

    <!-- PWA: Manifest + theme color -->
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="theme-color" content="#87ceeb">

    <!-- iOS install support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Skydive">
    <link rel="apple-touch-icon" href="/icons/icon-180.png">


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: "Arial", sans-serif;
        background: linear-gradient(
          180deg,
          #87ceeb 0%,
          #87ceeb 60%,
          #228b22 100%
        );
      }

      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        color: white;
        font-size: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }

      #instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        z-index: 200;
        max-width: 400px;
      }

      #startButton, #restartButton {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        border: none;
        color: white;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 30px;
        cursor: pointer;
        margin-top: 20px;
        transition: transform 0.2s;
        font-weight: bold;
      }

      #startButton:hover, #restartButton:hover {
        transform: scale(1.05);
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        z-index: 200;
        display: none;
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
        100% {
          opacity: 1;
        }
      }

      #altitude {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }

      #instructions, #gameOver {
          min-width: 280px;
      }

      footer {
        position:absolute;
        bottom:20px;
        left:50%;
        transform:translateX(-50%);
        color:white;
        text-align:center;
        
        display: flex;
        justify-content: space-between;
        align-items: center;

        width: 90%;
        font-size: 0.8em;
        text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.4);
      }

    </style>
  </head>
  <body>
    <main id="gameContainer">
      <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Speed: <span id="speed">0</span> kmh</div>
        <button id="calibrateBtn" style="margin-top:8px;border:none;border-radius:8px;padding:6px 10px;cursor:pointer">
          Recalibrate
        </button>
      </div>

      <div id="altitude">
        Altitude: <span id="altitudeValue">17000</span> ft
      </div>

      <div id="instructions">
        <h2>ðŸª‚ Skydive Collector</h2>
        <p>Fly through the sky and collect the balloons while falling</p>
        <p><strong>Desktop:</strong> Use WASD or Arrow Keys</p>
        <p><strong>Mobile:</strong> Tilt your device</p>
        <button id="startButton">Start Skydiving!</button>
      </div>

      <div id="gameOver">
        <h2>Mission Complete!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Balloons Collected: <span id="orbsCollected">0</span></p>
        <button id="restartButton" onclick="restartGame()">Jump Again!</button>
      </div>

    </main>


    <footer>
        <p>Created by <a href="https://github.com/pedroagont" target="_blank">@pedroagont</a></p>
        <p><a href="https://reservaparacaidismo.com/referidos/dbpKV/invitacion" target="_blank">Skydive in Mexico ðŸª‚ðŸ‡²ðŸ‡½</a></p>
    </footer>

    <script>
      let scene, camera, renderer, player;
      let orbs = [];
      let clouds = [];
      let gameStarted = false;
      let score = 0;
      let altitude = 17000;
      let speed = 200;
      let orbsCollectedCount = 0;

      // --- Tilt calibration & smoothing ---
      let deviceOrientation = { beta: 0, gamma: 0 };
      let orientationSupported = false;
      
      let baseline = { beta: 0, gamma: 0, angle: 0 };
      let calibrated = false;

      // smoothing state
      let smoothed = { x: 0, z: 0 };

      // tuning knobs
      const DEADZONE_DEG = 1.5;   // ignore tiny tilts (< ~2â€“3Âº feels good)
      const SMOOTHING = 0.8;     // 0.1â€“0.2 = smooth, >0.25 = snappier
      const MAX_MOVE = 2;         // caps raw move before scaling
      const SENS_X = 1 / 18;      // smaller = less sensitive (side tilt)
      const SENS_Z = 1 / 22;      // smaller = less sensitive (forward/back tilt)


      // Keyboard controls
      let keys = {};

      // Game settings
      const FALL_SPEED = 3;
      const ORB_COUNT = 80;
      const CLOUD_COUNT = 200;
      const GAME_HEIGHT = 17000;

      // Audio
      let bgMusic, finishSound, orbSound;
      const ORB_POOL_SIZE = 6;
      const orbPool = [];

      function initAudio() {
        bgMusic = new Audio("audio/background.mp3");
        finishSound = new Audio("audio/finish.mp3");
        orbSound = new Audio("audio/orb.mp3");

        [bgMusic, finishSound, orbSound].forEach(a => {
          a.preload = "auto";
          a.load();
        });

        // Make a small pool for overlapping orb hits
        for (let i = 0; i < ORB_POOL_SIZE; i++) {
          const c = orbSound.cloneNode(); // clones share decode, low overhead
          c.preload = "auto";
          c.load();
          orbPool.push(c);
        }

        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden") {
            try { bgMusic.pause(); } catch(_) {}
          } else if (gameStarted) {
            try { bgMusic.play(); } catch(_) {}
          }
        });
      }

      // Call in init()
      initAudio();

// Unlock on the same click that starts the game
async function unlockAudio() {
  const all = [bgMusic, finishSound, ...orbPool];
  await Promise.all(all.map(async (a) => {
    try {
      a.muted = true;
      a.currentTime = 0;
      await a.play();   // fulfills gesture requirement
      a.pause();
      a.currentTime = 0;
      a.muted = false;
    } catch (_) { /* ignore */ }
  }));
}

      function getScreenAngle() {
      // 0, 90, 180, 270 (or -90 on some browsers)
      const ang = (screen.orientation && typeof screen.orientation.angle === "number")
        ? screen.orientation.angle
        : (typeof window.orientation === "number" ? window.orientation : 0);
      // Normalize -90 to 270 for easier switch logic
      return (ang === -90) ? 270 : (ang % 360 + 360) % 360;
    }

    // Convert raw beta/gamma + current screen orientation into logical x/z tilts (in degrees),
    // *before* baseline subtraction and scaling.
    function mapTilts(beta, gamma) {
      const angle = getScreenAngle();
      // Portrait: x <- gamma (left/right), z <- beta (forward/back)
      // Landscape-left (90): x <- -beta, z <- gamma
      // Landscape-right (270): x <- beta, z <- -gamma
      // Portrait-upside-down (180): x <- -gamma, z <- -beta
      switch (angle) {
        case 0:   return { x: gamma,  z: beta,  angle };
        case 90:  return { x: -beta,  z: gamma, angle };
        case 180: return { x: -gamma, z: -beta, angle };
        case 270: return { x: beta,   z: -gamma, angle };
        default:  return { x: gamma,  z: beta,  angle };
      }
    }

    // Take N samples over ~600ms to set the neutral baseline
    function autoCalibrate(samples = 20, durationMs = 600) {
      return new Promise((resolve) => {
        let count = 0;
        let sumX = 0, sumZ = 0;
        const startAngle = getScreenAngle();

        const id = setInterval(() => {
          const mapped = mapTilts(deviceOrientation.beta, deviceOrientation.gamma);
          sumX += mapped.x;
          sumZ += mapped.z;
          count++;

          if (count >= samples) {
            clearInterval(id);
            baseline = {
              beta: 0, // not used directly post mapping
              gamma: 0,
              angle: startAngle,
              x: sumX / count,
              z: sumZ / count,
            };
            calibrated = true;
            resolve();
          }
        }, Math.max(10, Math.floor(durationMs / samples)));
      });
    }

    // Utility: apply deadzone and clamp
    function processTilt(rawDeg, deadzone, maxAbs) {
      const mag = Math.abs(rawDeg);
      if (mag < deadzone) return 0;
      // linear re-map after deadzone to keep feel consistent
      const sign = rawDeg < 0 ? -1 : 1;
      const adjusted = (mag - deadzone);
      return sign * Math.min(adjusted, maxAbs);
    }

      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 100, 2000);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          3000
        );
        camera.position.set(0, 0, 5);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87ceeb, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document
          .getElementById("gameContainer")
          .appendChild(renderer.domElement);

        // Create lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Create player (skydiver)
        createSkydiver();

        // Create orbs
        createOrbs();

        // Create clouds
        createClouds();

        // Setup controls
        setupControls();

        // Load audio files
        bgMusic = new Audio("audio/background.mp3");
        bgMusic.loop = true;
        bgMusic.volume = 0.3;

        finishSound = new Audio("audio/finish.mp3");
        finishSound.volume = 1;

        orbSound = new Audio("audio/orb.mp3");
        orbSound.volume = 1;

        // Start button event
        document
          .getElementById("startButton")
          .addEventListener("click", setupDeviceOrientation);

        // Window resize handler
        window.addEventListener("resize", onWindowResize);

        document.getElementById("calibrateBtn")?.addEventListener("click", async () => {
          // brief hint to the player
          const old = document.getElementById("calibrateBtn").textContent;
          document.getElementById("calibrateBtn").textContent = "Hold stillâ€¦";
          await autoCalibrate();
          document.getElementById("calibrateBtn").textContent = old;
        });

      }

      function createSkydiver() {
        // Root that your game moves/rotates (leave this as "player")
        const root = new THREE.Group();
        root.position.set(0, 0, 0);

        // Body group rotated to belly-to-earth (face toward -Y)
        const skydiver = new THREE.Group();
        skydiver.rotation.x = Math.PI / 2; // belly-to-earth orientation
        skydiver.rotation.z = Math.PI; // face forward
        root.add(skydiver);

        // Materials
        const suitMat   = new THREE.MeshLambertMaterial({ color: 0x1565c0 }); // suit
        const accentMat = new THREE.MeshLambertMaterial({ color: 0x0d47a1 }); // gloves/boots
        const rigMat    = new THREE.MeshLambertMaterial({ color: 0x333333 }); // parachute rig
        const helmetMat = new THREE.MeshLambertMaterial({ color: 0xffffff }); // helmet
        const visorMat  = new THREE.MeshLambertMaterial({ color: 0x88c9ff, transparent: true, opacity: 0.8 });

        // Torso
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.0, 0.35), suitMat);
        torso.position.set(0, 0.1, 0);
        skydiver.add(torso);

        // Head + visor (front is +Z)
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 16), helmetMat);
        head.position.set(0, 0.75, 0.02);
        skydiver.add(head);

        const visor = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.12, 0.02), visorMat);
        visor.position.set(0, 0.75, 0.17);
        skydiver.add(visor);

        // Parachute rig (on the back, -Z)
        const rig = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.15), rigMat);
        rig.position.set(0, 0.1, -0.25);
        skydiver.add(rig);

        // Arm builder (shoulder pivot -> upper -> elbow pivot -> forearm -> hand)
        // Arm builder (shoulder pivot -> upper group -> elbow pivot -> forearm group -> wrist pivot -> hand)
        function buildArm(side = 1) {
          const shoulder = new THREE.Group();
          shoulder.position.set(0.38 * side, 0.4, 0);

          // --- Upper arm (pivot at shoulder) ---
          const upperLen = 0.6;
          const upperG = new THREE.Group();               // transform group for upper arm
          shoulder.add(upperG);

          const upper = new THREE.Mesh(
            new THREE.CylinderGeometry(0.07, 0.07, upperLen, 8),
            suitMat
          );
          upper.rotation.z = Math.PI / 2;                 // cylinder axis -> X
          upper.position.x = (upperLen / 2) * side;       // half-length from shoulder pivot
          upperG.add(upper);

          // --- Elbow pivot at the end of the upper arm ---
          const elbow = new THREE.Group();
          elbow.position.x = upperLen * side;             // at upper tip
          shoulder.add(elbow);

          // --- Forearm (pivot at elbow) ---
          const foreLen = 0.5;
          const foreG = new THREE.Group();
          elbow.add(foreG);

          const fore = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, foreLen, 8),
            suitMat
          );
          fore.rotation.z = Math.PI / 2;                  // axis -> X
          fore.position.x = (foreLen / 2) * side;         // half-length from elbow pivot
          foreG.add(fore);

          // --- Wrist pivot at the end of the forearm ---
          const wrist = new THREE.Group();
          wrist.position.x = foreLen * side;              // at forearm tip
          foreG.add(wrist);

          // Hand (slightly longer/wider than before; oriented to airflow)
          const hand = new THREE.Mesh(
            new THREE.BoxGeometry(0.18, 0.10, 0.22),
            accentMat
          );
          hand.position.set(0.05 * side, 0, 0.0);         // tiny forward bias
          wrist.add(hand);

          // --- Pose: belly-fly (box) ---
          shoulder.rotation.x = 0.35;                     // arms slightly forward
          shoulder.rotation.z = 0.95 * side;              // wide

          // Natural elbow bend & bring forearms a touch toward +Z (into the wind)
          elbow.rotation.x = THREE.MathUtils.degToRad(12);     // flex
          elbow.rotation.y = THREE.MathUtils.degToRad(10) * side;

          // Small inward cant of forearm; subtle wrist pitch/pronation
          foreG.rotation.z = THREE.MathUtils.degToRad(8) * side;
          wrist.rotation.y = THREE.MathUtils.degToRad(8) * side;
          wrist.rotation.z = THREE.MathUtils.degToRad(-6);

          return { shoulder, elbow };
        }


        // Leg builder (hip pivot -> thigh -> knee pivot -> shin -> boot)
        function buildLeg(side = 1) {
          const hip = new THREE.Group();
          hip.position.set(0.18 * side, -0.5, 0.02);

          const thigh = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 0.7, 8), suitMat);
          thigh.position.y = -0.35;
          hip.add(thigh);

          const knee = new THREE.Group();
          knee.position.set(0, -0.7, 0);

          const shin = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.6, 8), suitMat);
          shin.position.y = -0.3;
          knee.add(shin);

          const boot = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.12, 0.3), accentMat);
          boot.position.set(0, -0.62, 0.05);
          knee.add(boot);

          // Belly-fly stance: legs apart, knees slightly bent, toes trailing
          hip.rotation.x = -0.1;                 // tiny hip arch (hips down)
          hip.rotation.z = 0.35 * side;          // spread
          knee.rotation.x = 0.35;                // bend knees

          hip.add(knee);
          return { hip, knee };
        }

        // Build limbs and add to skydiver (so they stay in belly orientation)
        const LArm = buildArm(+1);
        const RArm = buildArm(-1);
        skydiver.add(LArm.shoulder, RArm.shoulder);

        const LLeg = buildLeg(+1);
        const RLeg = buildLeg(-1);
        skydiver.add(LLeg.hip, RLeg.hip);

        // Shadows
        skydiver.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });

        // Keep optional handles for limb animation (if you added it elsewhere)
        root.userData.parts = {
          lShoulder: LArm.shoulder, rShoulder: RArm.shoulder,
          lElbow: LArm.elbow,       rElbow: RArm.elbow,
          lHip: LLeg.hip,           rHip: RLeg.hip,
          lKnee: LLeg.knee,         rKnee: RLeg.knee
        };

        // Finalize
        player = root;
        scene.add(player);
      }



      function createOrbs() {
        for (let i = 0; i < ORB_COUNT; i++) {
          const orbGeometry = new THREE.SphereGeometry(20, 20, 20);
          const hue = Math.random();
          const orbMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color().setHSL(hue, 1, 0.5),
            transparent: true,
            opacity: 0.8,
          });

          const orb = new THREE.Mesh(orbGeometry, orbMaterial);

          // Random position in the sky
          orb.position.set(
            (Math.random() - 0.5) * 200,
            Math.random() * GAME_HEIGHT - GAME_HEIGHT / 2,
            (Math.random() - 0.5) * 200
          );

          orb.userData = {
            originalY: orb.position.y,
            rotationSpeed: Math.random() * 0.05 + 0.02,
            collected: false,
            points: Math.floor(Math.random() * 50) + 10,
          };

          orbs.push(orb);
          scene.add(orb);
        }
      }

      function createClouds() {
        for (let i = 0; i < CLOUD_COUNT; i++) {
          const cloud = new THREE.Group();

          // Create cloud puffs
          for (let j = 0; j < 5; j++) {
            const puffGeometry = new THREE.SphereGeometry(
              Math.random() * 10 + 10,
              8,
              8
            );
            const puffMaterial = new THREE.MeshLambertMaterial({
              color: 0xffffff,
              transparent: true,
              opacity: 0.7,
            });
            const puff = new THREE.Mesh(puffGeometry, puffMaterial);

            puff.position.set(
              (Math.random() - 0.5) * 20,
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 20
            );

            cloud.add(puff);
          }

          cloud.position.set(
            (Math.random() - 0.5) * 300,
            Math.random() * GAME_HEIGHT - GAME_HEIGHT / 2,
            (Math.random() - 0.5) * 300
          );

          clouds.push(cloud);
          scene.add(cloud);
        }
      }

      function setupControls() {
        // Keyboard controls
        document.addEventListener("keydown", (event) => {
          keys[event.code] = true;
        });

        document.addEventListener("keyup", (event) => {
          keys[event.code] = false;
        });
      }

      function setupDeviceOrientation() {
        if (
          typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function"
        ) {
          // iOS 13+ permission request
          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              if (response == "granted") {
                enableOrientationControls();
                startGame();
              }
            })
            .catch(console.error);
        } else if (window.DeviceOrientationEvent) {
          // Other devices
          enableOrientationControls();
          startGame();
        }
      }

      function enableOrientationControls() {
        orientationSupported = true;
        window.addEventListener("deviceorientation", (event) => {
          deviceOrientation.beta = (event.beta  || 0); // Front-to-back tilt (-180 to 180)
          deviceOrientation.gamma = (event.gamma || 0); // Left-to-right tilt (-90 to 90)
        });
      }


      async function startGame() {
        document.getElementById("instructions").style.display = "none";
        await unlockAudio();          // << crucial
        gameStarted = true;
        try { await bgMusic.play(); } catch (_) {}
        await autoCalibrate();        // from previous fix
        animate();
      }


      function updatePlayer() {
        if (!gameStarted) return;

        let moveX = 0;
        let moveZ = 0;

        // Device orientation controls (with calibration + smoothing)
        if (orientationSupported && calibrated) {
          // Map current raw to logical x/z based on screen orientation
          const mapped = mapTilts(deviceOrientation.beta, deviceOrientation.gamma);

          // If the user rotated the screen since calibration, still behave sensibly:
          // Re-map baseline to *current* angle by just using stored neutral (x,z).
          // (For best UX, ask them to hit "Recalibrate" after rotating; this fallback still works decently.)
          const rawXdeg = mapped.x - baseline.x;
          const rawZdeg = mapped.z - baseline.z;

          // Deadzone + clamp
          const dzX = processTilt(rawXdeg, DEADZONE_DEG, 30);
          const dzZ = processTilt(rawZdeg, DEADZONE_DEG, 30);

          // Scale degrees â†’ movement unit
          const targetX = Math.max(-MAX_MOVE, Math.min(MAX_MOVE, dzX * SENS_X));
          const targetZ = Math.max(-MAX_MOVE, Math.min(MAX_MOVE, dzZ * SENS_Z));

          // Smooth (exponential moving average)
          smoothed.x += (targetX - smoothed.x) * SMOOTHING;
          smoothed.z += (targetZ - smoothed.z) * SMOOTHING;

          moveX = smoothed.x;
          moveZ = smoothed.z;
        }

        // Keyboard controls (override device orientation)
        if (keys["ArrowLeft"] || keys["KeyA"]) moveX = -1;
        if (keys["ArrowRight"] || keys["KeyD"]) moveX = 1;
        if (keys["ArrowUp"] || keys["KeyW"]) moveZ = -1;
        if (keys["ArrowDown"] || keys["KeyS"]) moveZ = 1;

        // Apply movement
        player.position.x += moveX * 3;
        player.position.z += moveZ * 3;

        // Keep player in bounds
        player.position.x = Math.max(-300, Math.min(300, player.position.x));
        player.position.z = Math.max(-300, Math.min(300, player.position.z));

        // Continuous falling
        player.position.y -= FALL_SPEED;
        altitude = Math.max(0, altitude - FALL_SPEED * 5);

        // Tilt player based on movement
        player.rotation.z = -moveX * 0.6;
        player.rotation.x = moveZ * 0.4;

        // Update camera to follow player
        camera.position.x = player.position.x;
        camera.position.y = player.position.y + 10;
        camera.position.z = player.position.z + 5;
        camera.lookAt(player.position.x, player.position.y, player.position.z);
      
        // --- Tracking pose blend (belly -> track) with subtle arm flutter ---
        if (player.userData && player.userData.parts) {
          const { lShoulder, rShoulder, lElbow, rElbow, lHip, rHip, lKnee, rKnee } = player.userData.parts;

          // helpers
          const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
          const lerp = (a, b, t) => a + (b - a) * t;
          const smoothstep = (e0, e1, x) => {
            const t = clamp((x - e0) / (e1 - e0), 0, 1);
            return t * t * (3 - 2 * t);
          };

          // input mapping
          const forward = clamp(-moveZ, 0, 1);      // 0..1 only when pushing forward
          const t = smoothstep(0.15, 0.9, forward); // blend bellyâ†’track
          const bank = clamp(moveX, -1, 1);

          // time-based flutter
          const time = performance.now() * 0.004;
          const flutterScale = 1 - 0.6 * t; // less flutter when tracking (sleeker body)
          const A_shX = THREE.MathUtils.degToRad(4) * flutterScale; // shoulder pitch wobble
          const A_shY = THREE.MathUtils.degToRad(2) * flutterScale; // tiny yaw wiggle
          const A_elX = THREE.MathUtils.degToRad(5) * flutterScale; // elbow flex

          // Belly (base) vs Track (target) angles
          const base = {
            shX: 0.35,              // shoulders slightly forward
            shZ: 0.95,              // arms wide
            elX: THREE.MathUtils.degToRad(12),
            elY: THREE.MathUtils.degToRad(10),
            hipX: -0.10,
            hipZ: 0.35,
            kneeX: 0.35
          };
          const track = {
            shX: -0.55,             // sweep arms back
            shZ: 0.15,              // closer to body
            elX: THREE.MathUtils.degToRad(0),   // straighter arms
            elY: THREE.MathUtils.degToRad(0),
            hipX: -0.25,            // slight hips-down
            hipZ: 0.15,             // legs nearer midline
            kneeX: 0.15             // straighter knees
          };

          function applySide(side, joints) {
            const s = side; // +1 = left, -1 = right
            const { shoulder, elbow, hip, knee } = joints;

            // Blend pose first
            shoulder.rotation.x = lerp(base.shX, track.shX, t);
            shoulder.rotation.z = lerp(base.shZ * s, track.shZ * s, t) + (-bank) * 0.15 * s;

            elbow.rotation.x = lerp(base.elX, track.elX, t);
            elbow.rotation.y = lerp(base.elY * s, track.elY * s, t);

            hip.rotation.x = lerp(base.hipX, track.hipX, t);
            hip.rotation.z = lerp(base.hipZ * s, track.hipZ * s, t) + (-bank) * 0.15 * s;
            knee.rotation.x = lerp(base.kneeX, track.kneeX, t);

            // --- Add subtle flutter (freefall buffeting) ---
            // Phase arms slightly out of sync for natural motion
            const phase = time + (s > 0 ? 0 : Math.PI * 0.6);

            // Shoulders: tiny pitch + yaw wobble
            shoulder.rotation.x += Math.sin(phase * 1.3) * A_shX;
            shoulder.rotation.y = (Math.sin(phase * 1.7) * A_shY); // centered around ~0

            // Elbows: gentle flex
            elbow.rotation.x += Math.sin(phase * 1.9) * A_elX;
          }

          applySide(+1, { shoulder: lShoulder, elbow: lElbow, hip: lHip, knee: lKnee });
          applySide(-1, { shoulder: rShoulder, elbow: rElbow, hip: rHip, knee: rKnee });
        }
      }

      function updateOrbs() {
        orbs.forEach((orb, index) => {
          if (orb.userData.collected) return;

          // Rotate orb
          orb.rotation.y += orb.userData.rotationSpeed;

          // Pulsing effect
          const pulse = Math.sin(Date.now() * 0.003 + index) * 0.1 + 0.9;
          orb.scale.setScalar(pulse);

          // Check collision with player
          const distance = player.position.distanceTo(orb.position);
          if (distance < 20) {
            collectOrb(orb, index);
          }
        });
      }

      function playFromPool(pool) {
        let a = pool.find(x => x.paused || x.ended);
        if (!a) {
          // optional: grow the pool if all are busy
          a = pool[0].cloneNode();
          pool.push(a);
        }
        try {
          a.currentTime = 0;
          const p = a.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        } catch (_) {}
      }


      function collectOrb(orb, index) {
        orb.userData.collected = true;
        score += orb.userData.points;
        orbsCollectedCount++;

        playFromPool(orbPool); // instead of orbSound.play()

        scene.remove(orb);
        orbs.splice(index, 1);
        createCollectionEffect(orb.position);
        document.getElementById("score").textContent = score;
      }


      function createCollectionEffect(position) {
        const particles = new THREE.Group();

        for (let i = 0; i < 10; i++) {
          const particleGeometry = new THREE.SphereGeometry(5, 4, 4);
          const particleMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
          });
          const particle = new THREE.Mesh(particleGeometry, particleMaterial);

          particle.position.copy(position);
          particle.userData = {
            velocity: new THREE.Vector3(
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 5
            ),
          };

          particles.add(particle);
        }

        scene.add(particles);

        // Animate particles
        let particleLife = 30;
        const animateParticles = () => {
          if (particleLife <= 0) {
            scene.remove(particles);
            return;
          }

          particles.children.forEach((particle) => {
            particle.position.add(particle.userData.velocity);
            particle.userData.velocity.multiplyScalar(0.95);
            particle.material.opacity = particleLife / 30;
          });

          particleLife--;
          requestAnimationFrame(animateParticles);
        };

        animateParticles();
      }

      function updateUI() {
        document.getElementById("speed").textContent = Math.floor(
          speed + Math.random() * 10
        );
        document.getElementById("altitudeValue").textContent =
          Math.floor(altitude);

        // Check game end condition
        if (altitude <= 0) {
          endGame();
        }
      }

      async function endGame() {
        gameStarted = false;
        document.getElementById("finalScore").textContent = score;
        document.getElementById("orbsCollected").textContent = orbsCollectedCount;
        document.getElementById("gameOver").style.display = "block";

        try { bgMusic.pause(); } catch(_) {}
        try {
          finishSound.currentTime = 0;
          await finishSound.play();
        } catch(_) {}
      }

      function restartGame() {
        // Reset game state
        score = 0;
        altitude = 17000;
        orbsCollectedCount = 0;
        gameStarted = false;

        // Reset player position
        player.position.set(0, 0, 0);

        // Clear and recreate orbs
        orbs.forEach((orb) => scene.remove(orb));
        orbs = [];
        createOrbs();

        // Hide game over screen
        document.getElementById("gameOver").style.display = "none";

        // Show instructions again
        document.getElementById("instructions").style.display = "block";

        // Update UI
        document.getElementById("score").textContent = score;
      }

      function animate() {
        if (!gameStarted) return;

        requestAnimationFrame(animate);

        updatePlayer();
        updateOrbs();
        updateUI();

        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Initialize the game
      init();
    </script>

    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js').catch(console.error);
        });
      }
    </script>

  </body>
</html>
