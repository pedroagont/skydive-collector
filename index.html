<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Skydrop Collector</title>

    <!-- Basic SEO -->
    <meta
      name="description"
      content="Dive from 17,000 ft in Skydrop Collector! Collect glowing orbs, race through the clouds, and land safely. Play on desktop or mobile with tilt controls."
    />
    <meta
      name="keywords"
      content="skydiving game, Skydrop Collector, orb collector, 3D browser game, Three.js skydiving, WebGL game, freefall simulator, tilt control game, parachute game, arcade sky game"
    />
    <meta name="author" content="Pedro Gonzalez" />
    <link rel="icon" type="image/png" href="./favicon.png" />

    <!-- Open Graph / Facebook -->
    <meta
      property="og:title"
      content="Skydrop Collector Game"
    />
    <meta
      property="og:description"
      content="Skydive from 17,000 ft, collect glowing orbs, and beat the high score! Works on desktop (WASD/Arrows) & mobile tilt controls."
    />
    <meta
      property="og:image"
      content="https://skydrop-collector.onrender.com/preview.jpg"
    />
    <meta property="og:url" content="https://skydrop-collector.onrender.com" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Skydrop Collector" />
    <meta property="og:locale" content="en_US" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="Skydrop Collector Game"
    />
    <meta
      name="twitter:description"
      content="Jump from 17,000 ft, race through the sky, and collect orbs before landing! Play on desktop or mobile."
    />
    <meta
      name="twitter:image"
      content="https://skydrop-collector.onrender.com/preview.jpg"
    />

    <!-- PWA: Manifest + theme color -->
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="theme-color" content="#87ceeb">

    <!-- iOS install support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Skydrop">
    <link rel="apple-touch-icon" href="/icons/icon-180.png">


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: "Arial", sans-serif;
        background: linear-gradient(
          180deg,
          #87ceeb 0%,
          #87ceeb 60%,
          #228b22 100%
        );
      }

      #gameContainer {
        position: relative;
        width: 100vw;
        height: 100vh;
      }

      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        color: white;
        font-size: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }

      #instructions {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        z-index: 200;
        max-width: 400px;
      }

      #startButton {
        background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
        border: none;
        color: white;
        padding: 15px 30px;
        font-size: 18px;
        border-radius: 30px;
        cursor: pointer;
        margin-top: 20px;
        transition: transform 0.2s;
      }

      #startButton:hover {
        transform: scale(1.05);
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        z-index: 200;
        display: none;
      }

      .pulse {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
        100% {
          opacity: 1;
        }
      }

      #altitude {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-size: 18px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      }
    </style>
  </head>
  <body>
    <div id="gameContainer">
      <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Speed: <span id="speed">0</span> kmh</div>
        <button id="calibrateBtn" style="margin-top:8px;border:none;border-radius:8px;padding:6px 10px;cursor:pointer">
          Recalibrate
        </button>
      </div>

      <div id="altitude">
        Altitude: <span id="altitudeValue">17000</span> ft
      </div>

      <div id="instructions">
        <h2>ðŸª‚ Skydrop Collector</h2>
        <p>Fly through the sky and collect the balloons while falling</p>
        <p><strong>Desktop:</strong> Use WASD or Arrow Keys</p>
        <p><strong>Mobile:</strong> Tilt your device</p>
        <button id="startButton">Start Skydrop!</button>
      </div>

      <div id="gameOver">
        <h2>Mission Complete!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Orbs Collected: <span id="orbsCollected">0</span></p>
        <button id="restartButton" onclick="restartGame()">Jump Again!</button>
      </div>

    </div>

    <script>
      let scene, camera, renderer, player;
      let orbs = [];
      let clouds = [];
      let gameStarted = false;
      let score = 0;
      let altitude = 17000;
      let speed = 200;
      let orbsCollectedCount = 0;

      // --- Tilt calibration & smoothing ---
      let deviceOrientation = { beta: 0, gamma: 0 };
      let orientationSupported = false;
      
      let baseline = { beta: 0, gamma: 0, angle: 0 };
      let calibrated = false;

      // smoothing state
      let smoothed = { x: 0, z: 0 };

      // tuning knobs
      const DEADZONE_DEG = 1.5;   // ignore tiny tilts (< ~2â€“3Âº feels good)
      const SMOOTHING = 0.8;     // 0.1â€“0.2 = smooth, >0.25 = snappier
      const MAX_MOVE = 2;         // caps raw move before scaling
      const SENS_X = 1 / 18;      // smaller = less sensitive (side tilt)
      const SENS_Z = 1 / 22;      // smaller = less sensitive (forward/back tilt)


      // Keyboard controls
      let keys = {};

      // Game settings
      const FALL_SPEED = 3;
      const ORB_COUNT = 80;
      const CLOUD_COUNT = 200;
      const GAME_HEIGHT = 17000;

      // Audio
      let bgMusic, finishSound, orbSound;
      const ORB_POOL_SIZE = 6;
      const orbPool = [];

      function initAudio() {
        bgMusic = new Audio("audio/background.mp3");
        finishSound = new Audio("audio/finish.mp3");
        orbSound = new Audio("audio/orb.mp3");

        [bgMusic, finishSound, orbSound].forEach(a => {
          a.preload = "auto";
          a.load();
        });

        // Make a small pool for overlapping orb hits
        for (let i = 0; i < ORB_POOL_SIZE; i++) {
          const c = orbSound.cloneNode(); // clones share decode, low overhead
          c.preload = "auto";
          c.load();
          orbPool.push(c);
        }

        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden") {
            try { bgMusic.pause(); } catch(_) {}
          } else if (gameStarted) {
            try { bgMusic.play(); } catch(_) {}
          }
        });
      }

      // Call in init()
      initAudio();

// Unlock on the same click that starts the game
async function unlockAudio() {
  const all = [bgMusic, finishSound, ...orbPool];
  await Promise.all(all.map(async (a) => {
    try {
      a.muted = true;
      a.currentTime = 0;
      await a.play();   // fulfills gesture requirement
      a.pause();
      a.currentTime = 0;
      a.muted = false;
    } catch (_) { /* ignore */ }
  }));
}

      function getScreenAngle() {
      // 0, 90, 180, 270 (or -90 on some browsers)
      const ang = (screen.orientation && typeof screen.orientation.angle === "number")
        ? screen.orientation.angle
        : (typeof window.orientation === "number" ? window.orientation : 0);
      // Normalize -90 to 270 for easier switch logic
      return (ang === -90) ? 270 : (ang % 360 + 360) % 360;
    }

    // Convert raw beta/gamma + current screen orientation into logical x/z tilts (in degrees),
    // *before* baseline subtraction and scaling.
    function mapTilts(beta, gamma) {
      const angle = getScreenAngle();
      // Portrait: x <- gamma (left/right), z <- beta (forward/back)
      // Landscape-left (90): x <- -beta, z <- gamma
      // Landscape-right (270): x <- beta, z <- -gamma
      // Portrait-upside-down (180): x <- -gamma, z <- -beta
      switch (angle) {
        case 0:   return { x: gamma,  z: beta,  angle };
        case 90:  return { x: -beta,  z: gamma, angle };
        case 180: return { x: -gamma, z: -beta, angle };
        case 270: return { x: beta,   z: -gamma, angle };
        default:  return { x: gamma,  z: beta,  angle };
      }
    }

    // Take N samples over ~600ms to set the neutral baseline
    function autoCalibrate(samples = 20, durationMs = 600) {
      return new Promise((resolve) => {
        let count = 0;
        let sumX = 0, sumZ = 0;
        const startAngle = getScreenAngle();

        const id = setInterval(() => {
          const mapped = mapTilts(deviceOrientation.beta, deviceOrientation.gamma);
          sumX += mapped.x;
          sumZ += mapped.z;
          count++;

          if (count >= samples) {
            clearInterval(id);
            baseline = {
              beta: 0, // not used directly post mapping
              gamma: 0,
              angle: startAngle,
              x: sumX / count,
              z: sumZ / count,
            };
            calibrated = true;
            resolve();
          }
        }, Math.max(10, Math.floor(durationMs / samples)));
      });
    }

    // Utility: apply deadzone and clamp
    function processTilt(rawDeg, deadzone, maxAbs) {
      const mag = Math.abs(rawDeg);
      if (mag < deadzone) return 0;
      // linear re-map after deadzone to keep feel consistent
      const sign = rawDeg < 0 ? -1 : 1;
      const adjusted = (mag - deadzone);
      return sign * Math.min(adjusted, maxAbs);
    }

      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87ceeb, 100, 2000);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          3000
        );
        camera.position.set(0, 0, 5);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87ceeb, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document
          .getElementById("gameContainer")
          .appendChild(renderer.domElement);

        // Create lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Create player (skydrop)
        createPlayer();

        // Create orbs
        createOrbs();

        // Create clouds
        createClouds();

        // Setup controls
        setupControls();

        // Load audio files
        bgMusic = new Audio("audio/background.mp3");
        bgMusic.loop = true;
        bgMusic.volume = 0.3;

        finishSound = new Audio("audio/finish.mp3");
        finishSound.volume = 1;

        orbSound = new Audio("audio/orb.mp3");
        orbSound.volume = 1;

        // Start button event
        document
          .getElementById("startButton")
          .addEventListener("click", setupDeviceOrientation);

        // Window resize handler
        window.addEventListener("resize", onWindowResize);

        document.getElementById("calibrateBtn")?.addEventListener("click", async () => {
          // brief hint to the player
          const old = document.getElementById("calibrateBtn").textContent;
          document.getElementById("calibrateBtn").textContent = "Hold stillâ€¦";
          await autoCalibrate();
          document.getElementById("calibrateBtn").textContent = old;
        });

      }

      function createPlayer() {
        const playerGeometry = new THREE.ConeGeometry(0.5, 2, 8);
        const playerMaterial = new THREE.MeshLambertMaterial({
          color: 0xff6b6b,
        });
        player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0, 0);
        player.castShadow = true;
        scene.add(player);

        // Add parachute cord effect
        const cordGeometry = new THREE.CylinderGeometry(0.02, 0.02, 3, 8);
        const cordMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
        const cord = new THREE.Mesh(cordGeometry, cordMaterial);
        cord.position.set(0, 1.5, 0);
        player.add(cord);
      }

      function createOrbs() {
        for (let i = 0; i < ORB_COUNT; i++) {
          const orbGeometry = new THREE.SphereGeometry(20, 20, 20);
          const hue = Math.random();
          const orbMaterial = new THREE.MeshLambertMaterial({
            color: new THREE.Color().setHSL(hue, 1, 0.5),
            transparent: true,
            opacity: 0.8,
          });

          const orb = new THREE.Mesh(orbGeometry, orbMaterial);

          // Random position in the sky
          orb.position.set(
            (Math.random() - 0.5) * 200,
            Math.random() * GAME_HEIGHT - GAME_HEIGHT / 2,
            (Math.random() - 0.5) * 200
          );

          orb.userData = {
            originalY: orb.position.y,
            rotationSpeed: Math.random() * 0.05 + 0.02,
            collected: false,
            points: Math.floor(Math.random() * 50) + 10,
          };

          orbs.push(orb);
          scene.add(orb);
        }
      }

      function createClouds() {
        for (let i = 0; i < CLOUD_COUNT; i++) {
          const cloud = new THREE.Group();

          // Create cloud puffs
          for (let j = 0; j < 5; j++) {
            const puffGeometry = new THREE.SphereGeometry(
              Math.random() * 10 + 10,
              8,
              8
            );
            const puffMaterial = new THREE.MeshLambertMaterial({
              color: 0xffffff,
              transparent: true,
              opacity: 0.7,
            });
            const puff = new THREE.Mesh(puffGeometry, puffMaterial);

            puff.position.set(
              (Math.random() - 0.5) * 20,
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 20
            );

            cloud.add(puff);
          }

          cloud.position.set(
            (Math.random() - 0.5) * 300,
            Math.random() * GAME_HEIGHT - GAME_HEIGHT / 2,
            (Math.random() - 0.5) * 300
          );

          clouds.push(cloud);
          scene.add(cloud);
        }
      }

      function setupControls() {
        // Keyboard controls
        document.addEventListener("keydown", (event) => {
          keys[event.code] = true;
        });

        document.addEventListener("keyup", (event) => {
          keys[event.code] = false;
        });
      }

      function setupDeviceOrientation() {
        if (
          typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function"
        ) {
          // iOS 13+ permission request
          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              if (response == "granted") {
                enableOrientationControls();
                startGame();
              }
            })
            .catch(console.error);
        } else if (window.DeviceOrientationEvent) {
          // Other devices
          enableOrientationControls();
          startGame();
        }
      }

      function enableOrientationControls() {
        orientationSupported = true;
        window.addEventListener("deviceorientation", (event) => {
          deviceOrientation.beta = (event.beta  || 0); // Front-to-back tilt (-180 to 180)
          deviceOrientation.gamma = (event.gamma || 0); // Left-to-right tilt (-90 to 90)
        });
      }


      async function startGame() {
        document.getElementById("instructions").style.display = "none";
        await unlockAudio();          // << crucial
        gameStarted = true;
        try { await bgMusic.play(); } catch (_) {}
        await autoCalibrate();        // from previous fix
        animate();
      }


      function updatePlayer() {
        if (!gameStarted) return;

        let moveX = 0;
        let moveZ = 0;

        // Device orientation controls (with calibration + smoothing)
        if (orientationSupported && calibrated) {
          // Map current raw to logical x/z based on screen orientation
          const mapped = mapTilts(deviceOrientation.beta, deviceOrientation.gamma);

          // If the user rotated the screen since calibration, still behave sensibly:
          // Re-map baseline to *current* angle by just using stored neutral (x,z).
          // (For best UX, ask them to hit "Recalibrate" after rotating; this fallback still works decently.)
          const rawXdeg = mapped.x - baseline.x;
          const rawZdeg = mapped.z - baseline.z;

          // Deadzone + clamp
          const dzX = processTilt(rawXdeg, DEADZONE_DEG, 30);
          const dzZ = processTilt(rawZdeg, DEADZONE_DEG, 30);

          // Scale degrees â†’ movement unit
          const targetX = Math.max(-MAX_MOVE, Math.min(MAX_MOVE, dzX * SENS_X));
          const targetZ = Math.max(-MAX_MOVE, Math.min(MAX_MOVE, dzZ * SENS_Z));

          // Smooth (exponential moving average)
          smoothed.x += (targetX - smoothed.x) * SMOOTHING;
          smoothed.z += (targetZ - smoothed.z) * SMOOTHING;

          moveX = smoothed.x;
          moveZ = smoothed.z;
        }

        // Keyboard controls (override device orientation)
        if (keys["ArrowLeft"] || keys["KeyA"]) moveX = -1;
        if (keys["ArrowRight"] || keys["KeyD"]) moveX = 1;
        if (keys["ArrowUp"] || keys["KeyW"]) moveZ = -1;
        if (keys["ArrowDown"] || keys["KeyS"]) moveZ = 1;

        // Apply movement
        player.position.x += moveX * 3;
        player.position.z += moveZ * 3;

        // Keep player in bounds
        player.position.x = Math.max(-300, Math.min(300, player.position.x));
        player.position.z = Math.max(-300, Math.min(300, player.position.z));

        // Continuous falling
        player.position.y -= FALL_SPEED;
        altitude = Math.max(0, altitude - FALL_SPEED * 5);

        // Tilt player based on movement
        player.rotation.z = -moveX * 0.6;
        player.rotation.x = moveZ * 0.4;

        // Update camera to follow player
        camera.position.x = player.position.x;
        camera.position.y = player.position.y + 10;
        camera.position.z = player.position.z + 5;
        camera.lookAt(player.position.x, player.position.y, player.position.z);
      }

      function updateOrbs() {
        orbs.forEach((orb, index) => {
          if (orb.userData.collected) return;

          // Rotate orb
          orb.rotation.y += orb.userData.rotationSpeed;

          // Pulsing effect
          const pulse = Math.sin(Date.now() * 0.003 + index) * 0.1 + 0.9;
          orb.scale.setScalar(pulse);

          // Check collision with player
          const distance = player.position.distanceTo(orb.position);
          if (distance < 20) {
            collectOrb(orb, index);
          }
        });
      }

      function playFromPool(pool) {
        let a = pool.find(x => x.paused || x.ended);
        if (!a) {
          // optional: grow the pool if all are busy
          a = pool[0].cloneNode();
          pool.push(a);
        }
        try {
          a.currentTime = 0;
          const p = a.play();
          if (p && typeof p.catch === "function") p.catch(() => {});
        } catch (_) {}
      }


      function collectOrb(orb, index) {
        orb.userData.collected = true;
        score += orb.userData.points;
        orbsCollectedCount++;

        playFromPool(orbPool); // instead of orbSound.play()

        scene.remove(orb);
        orbs.splice(index, 1);
        createCollectionEffect(orb.position);
        document.getElementById("score").textContent = score;
      }


      function createCollectionEffect(position) {
        const particles = new THREE.Group();

        for (let i = 0; i < 10; i++) {
          const particleGeometry = new THREE.SphereGeometry(5, 4, 4);
          const particleMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
          });
          const particle = new THREE.Mesh(particleGeometry, particleMaterial);

          particle.position.copy(position);
          particle.userData = {
            velocity: new THREE.Vector3(
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 5,
              (Math.random() - 0.5) * 5
            ),
          };

          particles.add(particle);
        }

        scene.add(particles);

        // Animate particles
        let particleLife = 30;
        const animateParticles = () => {
          if (particleLife <= 0) {
            scene.remove(particles);
            return;
          }

          particles.children.forEach((particle) => {
            particle.position.add(particle.userData.velocity);
            particle.userData.velocity.multiplyScalar(0.95);
            particle.material.opacity = particleLife / 30;
          });

          particleLife--;
          requestAnimationFrame(animateParticles);
        };

        animateParticles();
      }

      function updateUI() {
        document.getElementById("speed").textContent = Math.floor(
          speed + Math.random() * 10
        );
        document.getElementById("altitudeValue").textContent =
          Math.floor(altitude);

        // Check game end condition
        if (altitude <= 0) {
          endGame();
        }
      }

      async function endGame() {
        gameStarted = false;
        document.getElementById("finalScore").textContent = score;
        document.getElementById("orbsCollected").textContent = orbsCollectedCount;
        document.getElementById("gameOver").style.display = "block";

        try { bgMusic.pause(); } catch(_) {}
        try {
          finishSound.currentTime = 0;
          await finishSound.play();
        } catch(_) {}
      }

      function restartGame() {
        // Reset game state
        score = 0;
        altitude = 17000;
        orbsCollectedCount = 0;
        gameStarted = false;

        // Reset player position
        player.position.set(0, 0, 0);

        // Clear and recreate orbs
        orbs.forEach((orb) => scene.remove(orb));
        orbs = [];
        createOrbs();

        // Hide game over screen
        document.getElementById("gameOver").style.display = "none";

        // Show instructions again
        document.getElementById("instructions").style.display = "block";

        // Update UI
        document.getElementById("score").textContent = score;
      }

      function animate() {
        if (!gameStarted) return;

        requestAnimationFrame(animate);

        updatePlayer();
        updateOrbs();
        updateUI();

        renderer.render(scene, camera);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Initialize the game
      init();
    </script>

    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js').catch(console.error);
        });
      }
    </script>

  </body>
</html>
